- `인덱스`는 `KEY`라고도 말한다.
- 실행계획 `type`이 `const`로 나오면 `PRIMARY KEY`나 `UNIQUE KEY`라는 뜻으로 한건만 찾게 된다. 매우 빠르다.
- 인덱스로 고려해야 하는 컬럼
    - WHERE 절에서 비교하는 컬럼
    - ORDER BY로 정렬하는 컬럼
    - GROUP BY로 정렬하는 컬럼
    - [https://www.youtube.com/watch?v=_oRsPUqyr10&t=400s](https://www.youtube.com/watch?v=_oRsPUqyr10&t=370s)
- 인덱스가 여러가지 컬럼이 한꺼번에 걸려있는 경우 뒤에 나오는 컬럼만 조회시에 인덱스로 탐색하는 효과가 없다.
    - 예를들어 KEY (A, B) 라고 되어있으면 A로만 조회 했을때와 A, B로 조회했을 때는 인덱스를 사용하여서 빠르지만 B로만 조회하면 인덱스 효과가 없어진다. 그래서 KEY(A, B), KEY(B)로 2가지 인덱스를 거는 방법도 있다.
- 실행계획 type

	|type|설명|
	|---|---|
	|const|primary key나 unique key를 사용해서 1건을 가져오는 쿼리|
	|eq-ref|조인에서 두번째 이후에 읽는 테이블의 프라이머리 키로 조인|
	|ref|인덱스에 equal 검색|
	|fulltext|전문검색 인덱스(fulltext key)를 사용|
	|range|인덱스를 범위로 검색|
	|ALL|테이블 full scan|

    = 위에서부터 아래로 속도순서다.
    - 실행계획에서 가장 중요한것  중 하나가 type
- 조인걸때 N에서 1로 조인을 거는것이 1에서 N으로 조인을 거는 것보다 성능이 좋다. (찾아야 되는 컬럼이 하나니까)
- 일반적으로 where 절에 사용하는 컬럼을 기준으로 두고 조인을 사용하는것이 실행계획이 좋게 나온다.
- ALL 스캔이 항상 나쁜것은 아니다. 예를들어 성별은 M, F는 딱 2개인데 분포도가 너무 낮아서 (20%이하) 마리아디비가 인덱스를 사용하지 않는다.
`SHOW INDEX FROM 테이블명` 시에 `Cardinality`는 해당 인덱스의 중복되지 않는 값들을 추정치로 얘기하는데 `Cardinality가 한자리인 경우`는 인덱스가 크게 의미가 없다. (데이터가 많을 수록 의미가 있다는 뜻이구나)
